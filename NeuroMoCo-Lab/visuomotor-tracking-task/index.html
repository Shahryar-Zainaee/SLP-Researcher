<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Visuomotor tracking</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0f1115;
      --fg: #e7ecf5;
      --muted: #9fb0c7;
      --border: #243040;
      --accent: #7aa2ff;
      --target: #6cff9a;
      --warn: #ffb86b;
      --err: #ff6b6b;
    }

    html,
    body {
      margin: 0;
      height: 100%;
      background: var(--bg);
      color: var(--fg);
      font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif
    }

    .wrap {
      max-width: 1100px;
      margin: 0 auto;
      padding: 20px
    }

    h1 {
      font-size: 22px;
      margin: 0 0 8px
    }

    p {
      margin: 6px 0;
      color: var(--muted)
    }

    .row {
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
      margin: 8px 0 12px
    }

    label {
      display: flex;
      align-items: center;
      gap: 6px
    }

    input,
    select,
    textarea {
      border: 1px solid var(--border);
      background: #0b0e16;
      color: var(--fg);
      border-radius: 10px;
      padding: 8px
    }

    input[type="number"] {
      width: 120px
    }

    input[type="text"] {
      width: 160px
    }

    select {
      width: 200px
    }

    textarea {
      width: 520px;
      height: 60px
    }

    button {
      border: 1px solid var(--border);
      background: #111827;
      color: var(--fg);
      padding: 10px 14px;
      border-radius: 10px;
      cursor: pointer
    }

    button:disabled {
      opacity: .5;
      cursor: not-allowed
    }

    .stack {
      display: grid;
      place-items: center
    }

    canvas {
      display: block;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: #0b0e16;
      touch-action: none
    }

    .meta {
      display: flex;
      gap: 12px;
      margin-top: 8px;
      color: var(--muted);
      font-size: 14px;
      flex-wrap: wrap
    }

    .badge {
      padding: 2px 8px;
      border: 1px solid var(--border);
      border-radius: 999px
    }

    .pill {
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 4px 8px
    }

    .hint {
      font-size: 12px;
      color: var(--muted)
    }

    .ok {
      color: #6cff9a
    }

    .warn {
      color: var(--warn)
    }

    .err {
      color: var(--err)
    }

    .refs {
      margin-top: 16px;
      font-size: 12px;
      color: var(--muted);
      border-top: 1px solid var(--border);
      padding-top: 10px
    }

    .refs a {
      color: #7aa2ff;
      text-decoration: none
    }

    .prompt {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 42px;
      font-weight: 700;
      letter-spacing: 1px;
      text-align: center;
      white-space: pre-line
    }

    .prompt.show {
      display: flex
    }

    .settings {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px;
      margin-bottom: 10px
    }

    .hideBtn {
      margin-bottom: 10px
    }

    .controls {
      margin: 12px 0;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <h1>Adaptive visuomotor tracking task — modified</h1>

    <button id="toggleSettings" class="hideBtn">Hide Settings</button>
    <div id="settingsPanel" class="settings">
      <div class="row">
        <label>Participant ID <input id="pid" type="text" placeholder="e.g., S01"></label>
        <label>Condition <input id="cond" type="text" placeholder="e.g., Baseline"></label>
        <label>Canvas (W×H) <input id="cw" type="number" value="900">×<input id="ch" type="number" value="500"></label>
        <label>Target radius (px) <input id="dotR" type="number" value="12"></label>
        <label>Hit radius (px) <input id="hitR" type="number" value="18"></label>
      </div>
      <div class="row">
        <label>Adapt duration (s) <input id="adaptDur" type="number" value="60"></label>
        <label>Test duration (s) <input id="testDur" type="number" value="15"></label>
        <label>Start ω (deg/s) <input id="startDeg" type="number" value="20"></label>
        <label>Δω step (deg/s) <input id="stepDeg" type="number" value="5"></label>
        <label>TOT criterion (%) <input id="crit" type="number" value="70"></label>
        <label>Tolerance (±%) <input id="tol" type="number" value="5"></label>
      </div>
      <div class="row">
        <label>Cognitive load
          <select id="cog">
            <option value="least">Least (ignore colors)</option>
            <option value="low">Low (press on BLUE)</option>
            <option value="high">High (press on BLUE or YELLOW)</option>
          </select>
        </label>
        <label>Motor load
          <select id="motorLoad">
            <option value="simple">Simple (¼ × ω70)</option>
            <option value="moderate">Moderate (½ × ω70)</option>
            <option value="advanced" selected>Advanced (ω70)</option>
          </select>
        </label>
        <label>Pedal key
          <select id="pedalKey">
            <option value="ShiftLeft">Left Shift</option>
            <option value="Space">Space</option>
            <option value="Enter">Enter</option>
            <option value="KeyF">F</option>
          </select>
        </label>
        <span class="pill">Sampling: <span id="srBadge">60</span> Hz (per animation frame)</span>
      </div>
      <div class="row">
        <label>Swallowing
          <select id="swallowMode">
            <option value="off">OFF (no swallow)</option>
            <option value="on" selected>ON (sip & swallow)</option>
          </select>
        </label>
        <label>Swallow cue start (s) <input id="swallowStart" type="number" value="0" step="0.1"></label>
        <label>Swallow cue end (s) <input id="swallowEnd" type="number" value="15" step="0.1"></label>
        <span class="hint">Negative start = pre-trial cue (e.g., -2 → cue 2 s before start).</span>
      </div>
      <div class="row">
        <label>Acclimation reps <input id="repAccl" type="number" min="0" value="3"></label>
        <label>Adaptation reps <input id="repAdapt" type="number" min="0" value="1"></label>
        <label>Test reps (per setting) <input id="repTest" type="number" min="0" value="15"></label>
        <span class="hint">Test reps apply to the Test phase.</span>
      </div>
      <div class="row">
        <label style="flex:1 1 640px">Notes (saved into CSV):
          <textarea id="notes" placeholder="e.g., Booth display size; mouse type; participant notes"></textarea>
        </label>
      </div>
    </div>

    <div class="controls">
      <button id="startAccl">Start Acclimation</button>
      <button id="startAdapt">Start Adaptation</button>
      <button id="startTest">Start Test Trials</button>
      <button id="cancelBtn" disabled>Cancel</button>
      <button id="dlSummary" disabled>Download Summary CSV</button>
      <button id="dlSamples" disabled>Download Samples CSV</button>
    </div>

    <div class="stack" style="position:relative">
      <canvas id="board" width="900" height="500"></canvas>
      <div id="overlayPrompt" class="prompt"></div>
    </div>

    <div class="meta">
      <div class="badge">Phase: <span id="phase">—</span></div>
      <div class="badge">Trial: <span id="trial">—</span></div>
      <div class="badge">ω (deg/s): <span id="omega">—</span></div>
      <div class="badge">Time left: <span id="timeLeft">0.0</span>s</div>
      <div class="badge">Window TOT: <span id="winTOT">—</span></div>
      <div class="badge">Overall TOT: <span id="totAll">—</span></div>
      <div class="badge">Color: <span id="colorNow">—</span></div>
      <div class="badge">Pedal: <span id="pedalBadge">—</span></div>
    </div>
    <p id="status" class="hint"></p>

    <div class="refs">
      <b>References & Attribution.</b> Adaptive design aligned with <b>Whitfield, J. A., Holdosh, S. R., Kriegel, Z.,
        Sullivan, L. E., & Fullenkamp, A. M. (2021)</b>. Tracking the costs of clear and loud speech: Interactions
      between
      speech motor control and concurrent visuomotor tracking. Journal of Speech, Language, and Hearing Research,
      64(6S), 2182-2195.
    </div>
  </div>

  <script>
    (function () {
      const END_PROMPT_MS = 1500;

      const toggleBtn = document.getElementById('toggleSettings');
      const settingsPanel = document.getElementById('settingsPanel');
      toggleBtn.addEventListener('click', () => {
        if (settingsPanel.style.display === 'none') { settingsPanel.style.display = 'block'; toggleBtn.textContent = 'Hide Settings'; }
        else { settingsPanel.style.display = 'none'; toggleBtn.textContent = 'Show Settings'; }
      });

      const board = document.getElementById('board');
      const ctx = board.getContext('2d');
      const overlayPrompt = document.getElementById('overlayPrompt');

      const phaseEl = document.getElementById('phase');
      const trialEl = document.getElementById('trial');
      const omegaEl = document.getElementById('omega');
      const timeLeftEl = document.getElementById('timeLeft');
      const winTOTEl = document.getElementById('winTOT');
      const totAllEl = document.getElementById('totAll');
      const colorNowEl = document.getElementById('colorNow');
      const pedalBadgeEl = document.getElementById('pedalBadge');
      const statusEl = document.getElementById('status');

      const pidEl = document.getElementById('pid');
      const condEl = document.getElementById('cond');
      const cwEl = document.getElementById('cw');
      const chEl = document.getElementById('ch');
      const dotREl = document.getElementById('dotR');
      const hitREl = document.getElementById('hitR');

      const adaptDurEl = document.getElementById('adaptDur');
      const testDurEl = document.getElementById('testDur');
      const startDegEl = document.getElementById('startDeg');
      const stepDegEl = document.getElementById('stepDeg');
      const critEl = document.getElementById('crit');
      const tolEl = document.getElementById('tol');

      const cogEl = document.getElementById('cog');
      const motorLoadEl = document.getElementById('motorLoad');
      const pedalKeyEl = document.getElementById('pedalKey');

      const swallowModeEl = document.getElementById('swallowMode');
      const swallowStartEl = document.getElementById('swallowStart');
      const swallowEndEl = document.getElementById('swallowEnd');

      const repAcclEl = document.getElementById('repAccl');
      const repAdaptEl = document.getElementById('repAdapt');
      const repTestEl = document.getElementById('repTest');

      const notesEl = document.getElementById('notes');

      const startAcclBtn = document.getElementById('startAccl');
      const startAdaptBtn = document.getElementById('startAdapt');
      const startTestBtn = document.getElementById('startTest');
      const cancelBtn = document.getElementById('cancelBtn');
      const dlSummaryBtn = document.getElementById('dlSummary');
      const dlSamplesBtn = document.getElementById('dlSamples');

      const COLORS = ['red', 'white', 'orange', 'blue', 'green', 'brown', 'yellow'];
      const TRIGGER_SECONDS = [6, 8, 10, 13];
      const TWO_PI = Math.PI * 2;
      let omega70Rad = null;

      let mouse = { x: board.width / 2, y: board.height / 2 };
      board.addEventListener('pointermove', (e) => {
        const r = board.getBoundingClientRect();
        mouse.x = e.clientX - r.left; mouse.y = e.clientY - r.top;
      });
      board.addEventListener('pointerdown', (e) => { try { board.setPointerCapture(e.pointerId); } catch { } });

      let running = false, raf = null;
      let phase = '—'; let trialIndex = 0;

      let center = { x: board.width / 2, y: board.height / 2 };
      let R = Math.min(board.width, board.height) * 0.35;
      let theta = 0;
      let omega = 20 * Math.PI / 180;
      let dotR = 12, hitR = 18;
      let currentColor = 'white', lastColorChangeS = -1;

      let phaseStartTime = 0, phaseEndTime = 0, lastFrameTs = 0;
      let adaptActiveWindow = null, adaptHits = 0, adaptTotal = 0;
      let overallHits = 0, overallTotal = 0;

      let colorTimeline = [];
      let pedalPresses = [];
      let lastPedalAt = -Infinity;

      let swallowCueStart = null, swallowCueEnd = null;
      let swallowStartPlayed = false, swallowEndPlayed = false;

      let summaryRows = [[
        'ParticipantID', 'Condition', 'Phase', 'TrialIndex', 'CanvasW', 'CanvasH',
        'DotR_px', 'HitR_px', 'Adapt_Start_deg_s', 'Step_deg_s', 'TOT_Criterion_pct', 'Tolerance_pct',
        'Fixed_Omega_deg_s', 'Cognitive_Load', 'Motor_Load', 'Pedal_Key', 'Swallow_Mode', 'SwallowStart_s', 'SwallowEnd_s', 'Notes',
        'Phase_Duration_s', 'Overall_TOT_pct', 'BlueTimes_s', 'YellowTimes_s', 'Pedal_Hits', 'Pedal_FAs', 'Pedal_Misses', 'ISO_EndTime'
      ]];
      let sampleRows = [[
        'ParticipantID', 'Condition', 'Phase', 'TrialIndex', 't_s', 'TargetX', 'TargetY', 'MouseX', 'MouseY', 'Err_px', 'Inside', 'Omega_deg_s', 'Color', 'PedalPress', 'ISO'
      ]];

      const deg2rad = d => d * Math.PI / 180;
      const rad2deg = r => r * 180 / Math.PI;
      const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
      const now = () => performance.now();
      const fmt1 = x => Number.isFinite(x) ? x.toFixed(1) : '—';
      const round = (x, n) => Number.isFinite(x) ? Number(x.toFixed(n)) : '';

      function csvEsc(s) {
        const t = String(s ?? '');
        // quote any field that contains a quote or a newline
        return /[",\r\n]/.test(t) ? '"' + t.replace(/"/g, '""') + '"' : t;
      }

      function toCSV(rows) {
        // use CRLF newlines and add a BOM for Excel
        const body = rows.map(r => r.map(csvEsc).join(',')).join('\r\n');
        return '\ufeff' + body + '\r\n';
      }

      function downloadCSV(name, text) {
        const blob = new Blob([text], { type: 'text/csv;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = name; document.body.appendChild(a); a.click();
        URL.revokeObjectURL(url); a.remove();
      }

      function setPrompt(text, show = true) { overlayPrompt.textContent = text; overlayPrompt.className = show ? 'prompt show' : 'prompt' }

      function speak(text) { try { const u = new SpeechSynthesisUtterance(text); u.rate = 1; speechSynthesis.speak(u); } catch { beep(); } }
      function beep(freq = 600, dur = 0.2) {
        try {
          const a = new (window.AudioContext || window.webkitAudioContext)();
          const o = a.createOscillator(), g = a.createGain();
          o.type = 'sine'; o.frequency.value = freq; o.connect(g); g.connect(a.destination);
          g.gain.setValueAtTime(0.001, a.currentTime);
          g.gain.exponentialRampToValueAtTime(0.2, a.currentTime + 0.01);
          o.start(); o.stop(a.currentTime + dur);
        } catch { }
      }

      function targetPos() { return { x: center.x + R * Math.cos(theta), y: center.y + R * Math.sin(theta) } }
      function drawScene(tgt) {
        ctx.clearRect(0, 0, board.width, board.height);
        ctx.globalAlpha = 0.8; ctx.strokeStyle = '#243040';
        ctx.beginPath(); ctx.moveTo(mouse.x, 0); ctx.lineTo(mouse.x, board.height);
        ctx.moveTo(0, mouse.y); ctx.lineTo(board.width, mouse.y); ctx.stroke();
        ctx.globalAlpha = 0.15; ctx.beginPath(); ctx.arc(center.x, center.y, R, 0, TWO_PI); ctx.stroke();
        ctx.globalAlpha = 1; ctx.fillStyle = currentColor;
        ctx.beginPath(); ctx.arc(tgt.x, tgt.y, dotR, 0, TWO_PI); ctx.fill();
        ctx.globalAlpha = 0.18; ctx.beginPath(); ctx.arc(tgt.x, tgt.y, hitR, 0, TWO_PI); ctx.fill();
      }

      function pushSampleRow(t_s, pos, ped = '') {
        const pid = (pidEl.value || '').trim() || crypto.randomUUID().slice(0, 8);
        const cond = (condEl.value || '').trim() || 'NA';
        const err = Math.hypot(mouse.x - pos.x, mouse.y - pos.y);
        const inside = +(err <= hitR);
        sampleRows.push([
          pid, cond, phase, trialIndex, round(t_s, 3),
          round(pos.x, 2), round(pos.y, 2), round(mouse.x, 2), round(mouse.y, 2), round(err, 2), inside,
          round(rad2deg(omega), 2), currentColor, ped, new Date().toISOString()
        ]);
        overallTotal++; if (inside) overallHits++;
        if (phase === 'Adapt' && adaptActiveWindow) { adaptTotal++; if (inside) adaptHits++; }
      }

      function scheduleColors(phaseDur, mode) {
        colorTimeline = [];
        let prev = null;
        const triggers = new Map();
        if (mode === 'low') {
          TRIGGER_SECONDS.forEach(s => triggers.set(s, { blue: true, yellow: false }));
        } else if (mode === 'high') {
          let last = null;
          TRIGGER_SECONDS.forEach(s => {
            let pick = Math.random() < 0.5 ? 'blue' : 'yellow';
            if (last && pick !== last && Math.random() < 0.6) { pick = last; }
            triggers.set(s, { blue: pick === 'blue', yellow: pick === 'yellow' });
            last = pick;
          });
        }
        for (let s = 0; s < phaseDur; s++) {
          const pool = ['red', 'white', 'orange', 'blue', 'green', 'brown', 'yellow'].filter(c => c !== prev);
          let c = pool[Math.floor(Math.random() * pool.length)];
          const trg = triggers.get(s) || { blue: false, yellow: false };
          if (trg.blue) c = 'blue';
          if (trg.yellow) c = 'yellow';
          colorTimeline.push({ t_s: s, color: c, isTrigger: triggers.has(s) });
          prev = c;
        }
      }
      function colorAt(t_s) {
        const s = Math.max(0, Math.floor(t_s));
        return colorTimeline[Math.min(s, colorTimeline.length - 1)]?.color || 'white';
      }

      function motorFactor() {
        switch (motorLoadEl.value) {
          case 'simple': return 0.25;
          case 'moderate': return 0.50;
          default: return 1.00;
        }
      }

      window.addEventListener('keydown', (e) => {
        if (!running) return;
        if (e.code === pedalKeyEl.value) {
          const t = (now() - phaseStartTime) / 1000;
          const s = Math.floor(t);
          const expectedSecond = TRIGGER_SECONDS.includes(s);
          let hit = false, fa = false;
          if (cogEl.value === 'low') {
            hit = expectedSecond && colorAt(t) === 'blue';
            fa = !expectedSecond;
          } else if (cogEl.value === 'high') {
            const c = colorAt(t);
            hit = expectedSecond && (c === 'blue' || c === 'yellow');
            fa = !expectedSecond;
          } else {
            fa = true;
          }
          pedalPresses.push({ t_s: +t.toFixed(3), key: e.code, hit, falseAlarm: fa });
          pedalBadgeEl.textContent = hit ? 'HIT' : (fa ? 'FA' : 'press');
          pushSampleRow(t, targetPos(), hit ? 'HIT' : (fa ? 'FA' : 'press'));
        }
      });

      function setPhase(name) { phase = name; phaseEl.textContent = name; }
      function resetForPhase() {
        overallHits = overallTotal = 0; adaptHits = adaptTotal = 0; adaptActiveWindow = null;
        pedalPresses = []; lastPedalAt = -Infinity;
        currentColor = 'white'; lastColorChangeS = -1;
        swallowStartPlayed = swallowEndPlayed = false;
        colorTimeline = [];
        timeLeftEl.textContent = '0.0'; winTOTEl.textContent = '—'; totAllEl.textContent = '—'; pedalBadgeEl.textContent = '—';
      }
      function updateCanvasSize() {
        const w = clamp(parseInt(cwEl.value || '900', 10), 300, 1920);
        const h = clamp(parseInt(chEl.value || '500', 10), 200, 1200);
        board.width = w; board.height = h;
        center = { x: w / 2, y: h / 2 }; R = Math.min(w, h) * 0.35;
      }
      function windowSizeFor(t_s, total) {
        if (t_s < 10) return 1;
        if (t_s < 30) return 2;
        return Math.min(5, Math.max(1, Math.floor((total - t_s) >= 5 ? 5 : (total - t_s))));
      }
      function finalizeSummary(duration_s) {
        const pid = (pidEl.value || '').trim() || crypto.randomUUID().slice(0, 8);
        const cond = (condEl.value || '').trim() || 'NA';
        const fixedOmegaDeg = (phase === 'Adapt') ? '' : round(rad2deg(omega), 2);
        const note = notesEl.value || '';
        const overallTOTpct = overallTotal ? +(100 * overallHits / overallTotal).toFixed(1) : '';
        const blueTimes = colorTimeline.filter(x => x.color === 'blue').map(x => x.t_s).join('|');
        const yellowTimes = colorTimeline.filter(x => x.color === 'yellow').map(x => x.t_s).join('|');
        const hits = pedalPresses.filter(p => p.hit).length;
        const fas = pedalPresses.filter(p => p.falseAlarm).length;
        let misses = 0; if (cogEl.value === 'low' || cogEl.value === 'high') { misses = Math.max(0, TRIGGER_SECONDS.length - hits); }
        summaryRows.push([
          pid, cond, phase, trialIndex, board.width, board.height,
          dotR, hitR, parseFloat(startDegEl.value || '20'), parseFloat(stepDegEl.value || '5'),
          parseFloat(critEl.value || '70'), parseFloat(tolEl.value || '5'),
          fixedOmegaDeg, cogEl.value, motorLoadEl.value, pedalKeyEl.value, swallowModeEl.value,
          swallowCueStart ?? '', swallowCueEnd ?? '', note,
          duration_s, overallTOTpct, blueTimes, yellowTimes, hits, fas, misses, new Date().toISOString()
        ]);
      }

      function waitSeconds(s) { return new Promise(r => setTimeout(r, s * 1000)); }

      async function runTrial(duration_s, ruleText) {
        resetForPhase();
        dotR = clamp(parseInt(dotREl.value || '12', 10), 4, 40);
        hitR = clamp(parseInt(hitREl.value || '18', 10), 6, 120);
        scheduleColors(duration_s, cogEl.value);
        setPrompt('Follow the rule: \n\n' + ruleText, true);
        const startCue = parseFloat(swallowStartEl.value || '0');
        const endCue = parseFloat(swallowEndEl.value || '15');
        const swallowOn = (swallowModeEl.value === 'on');
        swallowCueStart = swallowOn ? startCue : null;
        swallowCueEnd = swallowOn ? endCue : null;

        if (swallowOn && startCue < 0) {
          await waitSeconds(Math.abs(startCue));
          speak('swallow'); setPrompt('SWALLOW', true);
          setTimeout(() => setPrompt('', false), 800);
          swallowStartPlayed = true;
        } else {
          await waitSeconds(7);
          setPrompt('', false);
        }

        phaseStartTime = now();
        phaseEndTime = phaseStartTime + duration_s * 1000;
        lastFrameTs = phaseStartTime;

        return new Promise(resolve => {
          running = true; startButtonsRunning();
          (function frameLoop(ts) {
            if (!running) { resolve('canceled'); return; }
            const t_s = (ts - phaseStartTime) / 1000;

            if (swallowOn && !swallowStartPlayed && startCue >= 0 && t_s >= startCue) {
              speak('swallow'); setPrompt('SWALLOW', true); setTimeout(() => setPrompt('', false), 800); swallowStartPlayed = true;
            }
            if (swallowOn && !swallowEndPlayed && isFinite(endCue) && t_s >= endCue) {
              beep(550, 0.15); swallowEndPlayed = true;
            }

            if (Math.floor(t_s) !== lastColorChangeS) { currentColor = colorAt(t_s); lastColorChangeS = Math.floor(t_s); }

            theta += omega * ((ts - lastFrameTs) / 1000); lastFrameTs = ts;
            const pos = targetPos();
            drawScene(pos);
            pushSampleRow(t_s, pos);

            omegaEl.textContent = round(rad2deg(omega), 1);
            colorNowEl.textContent = currentColor;
            timeLeftEl.textContent = fmt1(Math.max(0, (phaseEndTime - ts) / 1000));
            totAllEl.textContent = overallTotal ? `${(100 * overallHits / overallTotal).toFixed(1)}%` : '—';

            if (ts >= phaseEndTime) {
              running = false; startButtonsIdle();
              setPrompt('Trial over', true);
              setTimeout(() => setPrompt('', false), END_PROMPT_MS);
              resolve('done'); return;
            }
            raf = requestAnimationFrame(frameLoop);
          })(phaseStartTime);
        });
      }

      async function runAcclimation() {
        setPhase('Acclimation');
        const reps = clamp(parseInt(repAcclEl.value || '3', 10), 0, 99);
        const dur = clamp(parseInt(testDurEl.value || '15', 10), 5, 600);
        omega = deg2rad(parseFloat(startDegEl.value || '20'));
        for (let i = 1; i <= reps; i++) {
          trialIndex = i;
          const label = motorLoadEl.options[motorLoadEl.selectedIndex].text.split(' ')[0];
          const rule = (swallowModeEl.value === 'on') ? `[track @ ${label}]` : `[track @ ${label}]`;
          await runTrial(dur, rule);
          finalizeSummary(dur);
        }
      }

      async function runAdaptation() {
        setPhase('Adapt');
        const reps = clamp(parseInt(repAdaptEl.value || '1', 10), 0, 99);
        const dur = clamp(parseInt(adaptDurEl.value || '60', 10), 10, 900);
        const crit = clamp(parseFloat(critEl.value || '70'), 1, 99);
        const tol = clamp(parseFloat(tolEl.value || '5'), 0, 30);
        const step = deg2rad(parseFloat(stepDegEl.value || '5'));
        omega = deg2rad(parseFloat(startDegEl.value || '20'));

        for (let i = 1; i <= reps; i++) {
          trialIndex = i;
          resetForPhase();
          scheduleColors(dur, cogEl.value);
          setPrompt('Follow the rule: \n\n[track]', true); await waitSeconds(1.2); setPrompt('', false);

          phaseStartTime = now();
          phaseEndTime = phaseStartTime + dur * 1000;
          lastFrameTs = phaseStartTime;
          adaptActiveWindow = { startS: 0, endS: windowSizeFor(0, dur) };
          adaptHits = adaptTotal = 0;

          await new Promise(resolve => {
            running = true; startButtonsRunning();
            (function frameLoop(ts) {
              if (!running) { resolve('canceled'); return; }
              const t_s = (ts - phaseStartTime) / 1000;

              if (Math.floor(t_s) !== lastColorChangeS) { currentColor = colorAt(t_s); lastColorChangeS = Math.floor(t_s); }

              theta += omega * ((ts - lastFrameTs) / 1000); lastFrameTs = ts;
              const pos = targetPos(); drawScene(pos); pushSampleRow(t_s, pos);

              if (t_s >= adaptActiveWindow.endS || t_s >= dur) {
                const windowTOT = adaptTotal ? (100 * adaptHits / adaptTotal) : 0;
                winTOTEl.textContent = `${windowTOT.toFixed(1)}%`;
                const upper = crit + tol, lower = crit - tol;
                if (windowTOT > upper) { omega += step; }
                else if (windowTOT < lower) { omega = Math.max(step, omega - step); }
                const w = windowSizeFor(t_s, dur);
                adaptActiveWindow = { startS: t_s, endS: t_s + w };
                adaptHits = adaptTotal = 0;
              }

              omegaEl.textContent = round(rad2deg(omega), 1);
              timeLeftEl.textContent = fmt1(Math.max(0, (phaseEndTime - ts) / 1000));
              totAllEl.textContent = overallTotal ? `${(100 * overallHits / overallTotal).toFixed(1)}%` : '—';

              if (ts >= phaseEndTime) {
                running = false; startButtonsIdle();
                setPrompt('Trial over', true);
                setTimeout(() => setPrompt('', false), END_PROMPT_MS);
                resolve('done'); return;
              }
              raf = requestAnimationFrame(frameLoop);
            })(phaseStartTime);
          });

          finalizeSummary(dur);
          omega70Rad = omega;
        }
      }

      async function runTests() {
        setPhase('Test');
        const reps = clamp(parseInt(repTestEl.value || '1', 10), 0, 99);
        const dur = clamp(parseInt(testDurEl.value || '15', 10), 5, 600);
        const baseOmega = (omega70Rad && omega70Rad > 0) ? omega70Rad : deg2rad(parseFloat(startDegEl.value || '20'));

        for (let i = 1; i <= reps; i++) {
          trialIndex = i;
          const label = motorLoadEl.options[motorLoadEl.selectedIndex].text.split(' ')[0];
          omega = baseOmega * motorFactor();
          const rule = (swallowModeEl.value === 'on') ? `[track + swallow @ ${label}]` : `[track only @ ${label}]`;
          await runTrial(dur, rule);
          finalizeSummary(dur);
        }
      }

      function startButtonsRunning() {
        startAcclBtn.disabled = true; startAdaptBtn.disabled = true; startTestBtn.disabled = true;
        cancelBtn.disabled = false; dlSummaryBtn.disabled = true; dlSamplesBtn.disabled = true;
      }
      function startButtonsIdle() {
        cancelBtn.disabled = true; startAcclBtn.disabled = false; startAdaptBtn.disabled = false; startTestBtn.disabled = false;
        const hasSummary = summaryRows.length > 1, hasSamples = sampleRows.length > 1;
        dlSummaryBtn.disabled = !hasSummary; dlSamplesBtn.disabled = !hasSamples;
      }
      function cancelAll() {
        if (!running) { startButtonsIdle(); return; }
        running = false; if (raf) cancelAnimationFrame(raf);
        statusEl.textContent = 'Canceled. Data up to cancel are preserved.';
        setPrompt('', false);
        startButtonsIdle();
      }

      startAcclBtn.addEventListener('click', async () => { updateCanvasSize(); setPhase('Acclimation'); trialEl.textContent = '—'; await runAcclimation(); statusEl.textContent = 'Acclimation complete.'; });
      startAdaptBtn.addEventListener('click', async () => { updateCanvasSize(); setPhase('Adapt'); trialEl.textContent = '—'; await runAdaptation(); statusEl.textContent = 'Adaptation complete.'; });
      startTestBtn.addEventListener('click', async () => { updateCanvasSize(); setPhase('Test'); trialEl.textContent = '—'; await runTests(); statusEl.textContent = 'Tests complete.'; });
      cancelBtn.addEventListener('click', cancelAll);

      dlSummaryBtn.addEventListener('click', () => downloadCSV('rotor_summary.csv', toCSV(summaryRows)));
      dlSamplesBtn.addEventListener('click', () => downloadCSV('rotor_samples.csv', toCSV(sampleRows)));

      function init() {
        dotR = clamp(parseInt(dotREl.value || '12', 10), 4, 40);
        hitR = clamp(parseInt(hitREl.value || '18', 10), 6, 120);
        updateCanvasSize();
        drawScene(targetPos());
        document.getElementById('srBadge').textContent = '60';
      }
      init();
    })();
  </script>
</body>

</html>
