<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Pursuit Rotor Task â€” Single File</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Load jsPsych v8.2.2 from CDN -->
  <script src="https://unpkg.com/jspsych@8.2.2/dist/jspsych.js"></script>
  <link href="https://unpkg.com/jspsych@8.2.2/css/jspsych.css" rel="stylesheet" />

  <style>
    body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: #0f1115;
      color: #e7ecf5;
    }
    #rotor-canvas {
      display: block;
      margin: 0 auto;
      border: 2px solid #243040;
      border-radius: 8px;
      background: #0b0e16;
    }
    .jspsych-content-wrapper {
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
    }
  </style>
</head>
<body>
  <div id="jspsych-target"></div>

  <script>
    // --- Helpers ---
    function seededPRNG(seed) {
      let x = Math.sin(seed) * 10000;
      return () => {
        x = Math.sin(x) * 10000;
        return x - Math.floor(x);
      };
    }
    function buildSchedules(trial, rng) {
      const switches = [];
      const shapes = ["circle", "square", "triangle"];
      for (let i = 0; i < trial.nSwitches; i++) {
        switches.push({
          t_ms: Math.floor(trial.minSwitchMs + rng() * (trial.maxSwitchMs - trial.minSwitchMs)),
          shape: shapes[i % shapes.length]
        });
      }
      return { switches };
    }
    function computeTargetPosition(t, trial, schedules) {
      const r = Math.min(trial.canvasWidth, trial.canvasHeight) / 3;
      const x = trial.canvasWidth/2 + r * Math.cos(trial.velocity * t);
      const y = trial.canvasHeight/2 + r * Math.sin(trial.velocity * t);
      return {x, y};
    }
    function drawTarget(ctx, pos, shape) {
      ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height);
      ctx.fillStyle = "red";
      if (shape === "circle") {
        ctx.beginPath();
        ctx.arc(pos.x,pos.y,15,0,2*Math.PI);
        ctx.fill();
      } else if (shape === "square") {
        ctx.fillRect(pos.x-15,pos.y-15,30,30);
      } else if (shape === "triangle") {
        ctx.beginPath();
        ctx.moveTo(pos.x, pos.y-20);
        ctx.lineTo(pos.x-20, pos.y+20);
        ctx.lineTo(pos.x+20, pos.y+20);
        ctx.closePath();
        ctx.fill();
      }
    }

    // --- Plugin definition ---
    class RotorPlugin {
      static info = {
        name: 'rotor',
        parameters: {
          duration_s: { type: "int", default: 10 },
          sampleMs: { type: "int", default: 20 },
          canvasWidth: { type: "int", default: 800 },
          canvasHeight: { type: "int", default: 600 },
          pathType: { type: "string", default: "circle" },
          velocity: { type: "float", default: 1.0 },
          complexity: { type: "int", default: 2 },
          nSwitches: { type: "int", default: 5 },
          minSwitchMs: { type: "int", default: 800 },
          maxSwitchMs: { type: "int", default: 1500 },
          freezeMinMs: { type: "int", default: 500 },
          freezeMaxMs: { type: "int", default: 2000 },
          nJitters: { type: "int", default: 0 },
          jitterMagnitudePx: { type: "float", default: 10 },
          jitterDurationMs: { type: "int", default: 100 },
          seed: { type: "int", default: 42 },
          participantId: { type: "string", default: "" },
          conditionLabel: { type: "string", default: "" }
        }
      };
      constructor(jsPsych) {
        this.jsPsych = jsPsych;
      }
      trial(display_element, trial) {
        display_element.innerHTML =
          `<canvas id="rotor-canvas" width="${trial.canvasWidth}" height="${trial.canvasHeight}"></canvas>`;
        const canvas = document.getElementById('rotor-canvas');
        const ctx = canvas.getContext('2d');

        const rng = seededPRNG(trial.seed);
        const schedules = buildSchedules(trial, rng);

        let mouse = { x: trial.canvasWidth/2, y: trial.canvasHeight/2 };
        canvas.addEventListener('mousemove', e => {
          const rect = canvas.getBoundingClientRect();
          mouse.x = e.clientX - rect.left;
          mouse.y = e.clientY - rect.top;
        });

        let samples = [];
        let startTime = performance.now();
        let endTime = startTime + trial.duration_s * 1000;
        let nextSampleAt = startTime;

        const frame = (now) => {
          if (now >= endTime) {
            endTrial();
            return;
          }
          let currentShape = 'circle';
          for (let s of schedules.switches) {
            if (now - startTime >= s.t_ms) {
              currentShape = s.shape;
            }
          }
          schedules.currentShape = currentShape;
          while (now >= nextSampleAt && nextSampleAt <= endTime) {
            const t_ms = Math.round(nextSampleAt - startTime);
            const pos = computeTargetPosition(t_ms/1000, trial, schedules);
            const err = Math.hypot(mouse.x - pos.x, mouse.y - pos.y);
            samples.push({
              t_ms, targetX: pos.x, targetY: pos.y,
              mouseX: mouse.x, mouseY: mouse.y,
              error_px: err, shape: currentShape
            });
            nextSampleAt += trial.sampleMs;
          }
          const pos = computeTargetPosition((now-startTime)/1000, trial, schedules);
          drawTarget(ctx, pos, currentShape);
          requestAnimationFrame(frame);
        };
        requestAnimationFrame(frame);

        const endTrial = () => {
          display_element.innerHTML = '';
          this.jsPsych.finishTrial({
            participantId: trial.participantId,
            conditionLabel: trial.conditionLabel,
            samples, schedules
          });
        };
      }
    }
    jsPsych.plugins['rotor'] = RotorPlugin;

    // --- Initialize jsPsych ---
    const jsPsych = initJsPsych({
      display_element: 'jspsych-target',
      on_finish: () => { jsPsych.data.displayData('json'); }
    });

    const timeline = [{
      type: RotorPlugin,
      duration_s: 5,
      participantId: "demo",
      conditionLabel: "test"
    }];

    jsPsych.run(timeline);
  </script>
</body>
</html>
